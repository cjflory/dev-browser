#!/bin/bash

# =============================================================================
# Dev Browser v2.0.0
# =============================================================================
# Creates custom browser app bundles with DNS override rules for development
#
# This script helps developers create isolated browser instances that redirect
# specific hostnames to different IP addresses. Useful for local development
# where you need to test against different environments while maintaining
# the same hostnames as production.
#
# Author: cjflory
# License: MIT
# =============================================================================

# Exit immediately if any command fails (makes debugging easier)
set -e

# Version information
VERSION="2.1.0"

# Function to display help information
show_help() {
    echo "üî® Dev Browser v${VERSION}"
    echo "Creates custom browser apps with DNS override rules for development"
    echo ""
    echo "üìù Usage: $0 <command> [options]"
    echo ""
    echo "‚öôÔ∏è Commands:"
    echo "  install            Install dev-browser from GitHub"
    echo "  uninstall          Uninstall dev-browser from system"
    echo "  create             Create a new browser app (interactive)"
    echo "  list               List all created browser apps"
    echo "  remove <app-id>    Remove a browser app by ID"
    echo "  help               Show this help message"
    echo "  version            Show version information"
    echo ""
    echo "üí° Examples:"
    echo "  $0 install             # Install from GitHub"
    echo "  $0 create              # Create new browser app"
    echo "  $0 list                # List created apps"
    echo "  $0 remove app-id       # Remove app by ID"
    echo "  $0 uninstall           # Uninstall from system"
}

# Function to display version information
show_version() {
    echo "üî® Dev Browser v${VERSION}"
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions for colored output
print_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
print_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
print_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
print_error() { echo -e "${RED}‚ùå $1${NC}"; }

# Configuration for install/uninstall
REPO_URL="https://github.com/cjflory/dev-browser"
RAW_URL="https://raw.githubusercontent.com/cjflory/dev-browser/main"
INSTALL_DIR_DEFAULT="$HOME/.local/share/dev-browser"
BIN_DIR_DEFAULT="$HOME/.local/bin"

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# =============================================================================
# APP REGISTRY FUNCTIONS
# =============================================================================

# Function: get_registry_path
# Purpose: Returns the path to the app registry file
# Parameters: None
# Returns: Prints the registry file path to stdout
get_registry_path() {
    local registry_dir="$HOME/.local/share/dev-browser"
    echo "$registry_dir/apps.tsv"
}

# Function: ensure_registry_exists
# Purpose: Creates the registry file if it doesn't exist
# Parameters: None
# Returns: 0 on success, 1 on failure
ensure_registry_exists() {
    local registry_path
    registry_path=$(get_registry_path)
    local registry_dir
    registry_dir=$(dirname "$registry_path")
    
    # Create registry directory if it doesn't exist
    mkdir -p "$registry_dir"
    
    # Create empty registry with header if it doesn't exist
    if [[ ! -f "$registry_path" ]]; then
        echo -e "id\tname\tbundle_path\tinstall_dir\tprofile_name\tbrowser_name\tbrowser_exec_path\tdns_rules\tcreated_at\ticon_type" > "$registry_path"
    fi
}

# Function: generate_app_id
# Purpose: Generates a unique ID for an app based on name and timestamp
# Parameters: $1 - App name
# Returns: Prints the generated ID to stdout
generate_app_id() {
    local app_name="$1"
    local timestamp=$(date +%s)
    
    # Create ID from app name and timestamp hash
    # Replace spaces with dashes and convert to lowercase
    local base_id=$(echo "$app_name" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
    echo "${base_id}-${timestamp}"
}

# Function: register_app
# Purpose: Adds an app entry to the registry
# Parameters: All app details as globals (APP_NAME, APP_BUNDLE, etc.)
# Returns: 0 on success, 1 on failure
register_app() {
    local registry_path
    registry_path=$(get_registry_path)
    
    ensure_registry_exists
    
    # Generate unique ID for this app
    local app_id
    app_id=$(generate_app_id "$APP_NAME")
    
    # Create timestamp in ISO 8601 format
    local created_at
    created_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    # Convert DNS_RULES array to pipe-separated format
    local dns_rules_str=""
    if [[ ${#DNS_RULES[@]} -gt 0 ]]; then
        for rule in "${DNS_RULES[@]}"; do
            local hostname=$(echo "$rule" | awk '{print $1}')
            local ip=$(echo "$rule" | awk '{print $2}')
            
            if [[ -n "$dns_rules_str" ]]; then
                dns_rules_str+="|"
            fi
            dns_rules_str+="${hostname}:${ip}"
        done
    fi
    
    # Determine icon type
    local icon_type="generated"
    if [[ -n "$ICON_PATH" && -f "$ICON_PATH" ]]; then
        icon_type="custom"
    fi
    
    # Escape tab characters in fields (replace tabs with spaces)
    local safe_name=$(echo "$APP_NAME" | tr '\t' ' ')
    local safe_bundle_path=$(echo "$APP_BUNDLE" | tr '\t' ' ')
    local safe_install_dir=$(echo "$INSTALL_DIR" | tr '\t' ' ')
    local safe_profile_name=$(echo "$PROFILE_NAME" | tr '\t' ' ')
    local safe_browser_name=$(echo "$BROWSER_NAME" | tr '\t' ' ')
    local safe_browser_exec_path=$(echo "$BROWSER_EXEC_PATH" | tr '\t' ' ')
    
    # Append new app entry to registry file
    if echo -e "${app_id}\t${safe_name}\t${safe_bundle_path}\t${safe_install_dir}\t${safe_profile_name}\t${safe_browser_name}\t${safe_browser_exec_path}\t${dns_rules_str}\t${created_at}\t${icon_type}" >> "$registry_path"; then
        echo "Registered app: $APP_NAME"
        return 0
    else
        echo "Failed to register app" >&2
        return 1
    fi
}

# Function: list_apps
# Purpose: Display all tracked browser apps from the registry
# Parameters: None
# Returns: 0 on success, 1 on error
list_apps() {
    local registry_path
    registry_path=$(get_registry_path)
    
    # Check if registry exists
    if [[ ! -f "$registry_path" ]]; then
        echo "üì≠ No browser apps found."
        echo "Create your first app by running: $0 create"
        return 0
    fi
    
    # Count apps (skip header line)
    local app_count
    app_count=$(tail -n +2 "$registry_path" | wc -l | tr -d ' ')
    
    if [[ $app_count -eq 0 ]]; then
        echo "üì≠ No browser apps found."
        echo "Create your first app by running: $0 create"
        return 0
    fi
    
    # Header
    echo "üì± Found $app_count browser app$([ $app_count -ne 1 ] && echo "s"):"
    echo
    
    # Read and display each app (skip header line)
    local line_num=1
    tail -n +2 "$registry_path" | while IFS=$'\t' read -r id name bundle_path install_dir profile_name browser_name browser_exec_path dns_rules created_at icon_type; do
        # Check if app bundle still exists
        local status_icon="‚úÖ"
        if [[ ! -e "$bundle_path" ]]; then
            status_icon="‚ùå"
        fi
        
        # Format creation date (extract date and time from ISO 8601)
        local formatted_date
        if [[ "$created_at" =~ ^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}) ]]; then
            formatted_date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]} ${BASH_REMATCH[4]}:${BASH_REMATCH[5]}"
        else
            formatted_date="$created_at"
        fi
        
        # App header
        echo "${line_num}. ${status_icon} ${name}"
        echo "   ID: ${id}"
        echo "   Bundle: ${bundle_path}"
        echo "   Browser: ${browser_name}"
        echo "   Profile: ${profile_name}"
        echo "   Created: ${formatted_date}"
        echo "   Icon: ${icon_type}"
        
        # Parse and display DNS rules
        if [[ -n "$dns_rules" ]]; then
            # Count rules by counting pipe separators + 1
            local rule_count
            rule_count=$(echo "$dns_rules" | tr -cd '|' | wc -c)
            rule_count=$((rule_count + 1))
            
            echo "   DNS Rules (${rule_count}):"
            
            # Split on pipes and display each rule
            echo "$dns_rules" | tr '|' '\n' | while IFS=':' read -r hostname ip; do
                echo "     ‚Ä¢ ${hostname} ‚Üí ${ip}"
            done
        else
            echo "   DNS Rules: none"
        fi
        
        if [[ "$status_icon" == "‚ùå" ]]; then
            echo "   ‚ö†Ô∏è  App bundle no longer exists"
        fi
        
        echo
        ((line_num++))
    done
    
    # Footer info
    echo "Tips:"
    echo "   ‚Ä¢ Use app ID to remove: $0 remove <app-id>"
    echo "   ‚Ä¢ Apps with ‚ùå may have been manually deleted"
}

# Function: remove_app
# Purpose: Remove a browser app by ID, with optional profile cleanup
# Parameters: $1 - App ID to remove
# Returns: 0 on success, 1 on error
remove_app() {
    local app_id="$1"
    local registry_path
    registry_path=$(get_registry_path)
    
    # Check if registry exists
    if [[ ! -f "$registry_path" ]]; then
        echo "‚ùå No browser apps found to remove."
        return 1
    fi
    
    # Search for app in registry
    local app_line
    app_line=$(tail -n +2 "$registry_path" | grep "^${app_id}"$'\t')
    
    if [[ -z "$app_line" ]]; then
        echo "‚ùå App with ID '$app_id' not found."
        echo "   Use '$0 list' to see available app IDs"
        return 1
    fi
    
    # Parse app details
    IFS=$'\t' read -r id name bundle_path install_dir profile_name browser_name browser_exec_path dns_rules created_at icon_type <<< "$app_line"
    
    # Show what will be removed
    echo "üóëÔ∏è  Removing browser app: $name"
    echo "   ID: $id"
    echo "   Bundle: $bundle_path"
    echo "   Profile: ~/chrome-profiles/$profile_name"
    echo
    
    # Confirmation
    read -p "‚ö†Ô∏è  Are you sure you want to remove this app? (y/N): " -n 1 -r || true
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Removal cancelled."
        return 0
    fi
    
    # Remove app bundle if it exists
    if [[ -e "$bundle_path" ]]; then
        if rm -rf "$bundle_path"; then
            echo "   App bundle removed: $bundle_path"
        else
            echo "   Failed to remove app bundle: $bundle_path"
        fi
    else
        echo "   App bundle not found (may have been manually deleted)"
    fi
    
    # Ask about profile cleanup
    local profile_dir="$HOME/chrome-profiles/$profile_name"
    if [[ -d "$profile_dir" ]]; then
        echo
        echo "Browser profile found: $profile_dir"
        echo "   Contains browser data (bookmarks, passwords, history, etc.)"
        read -p "Remove profile directory? (y/N): " -n 1 -r || true
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            if rm -rf "$profile_dir"; then
                echo "   Profile directory removed: $profile_dir"
            else
                echo "   Failed to remove profile directory: $profile_dir"
            fi
        else
            echo "   Profile directory preserved: $profile_dir"
        fi
    fi
    
    # Remove from registry (create temp file without the app line)
    local temp_registry=$(mktemp)
    
    # Copy header
    head -n 1 "$registry_path" > "$temp_registry" || true
    
    # Copy all lines except the one with matching app ID
    tail -n +2 "$registry_path" | grep -v "^${app_id}"$'\t' >> "$temp_registry" || true
    
    # Replace registry file
    if mv "$temp_registry" "$registry_path"; then
        echo "   Removed from registry"
        echo
        echo "‚úÖ Successfully removed browser app: $name"
    else
        echo "   Failed to update registry"
        rm -f "$temp_registry"
        return 1
    fi
}

# =============================================================================
# BROWSER DETECTION AND UTILITY FUNCTIONS  
# =============================================================================

# Function: validate_app_name
# Purpose: Validates that app names don't contain problematic characters
# Parameters: $1 - The app name to validate
# Returns: 0 if valid, 1 if invalid
# Notes: macOS app bundles can't contain certain filesystem characters
validate_app_name() {
    local name="$1"
    
    # Check if name is empty
    if [[ -z "$name" ]]; then
        return 1  # Empty name is invalid
    fi
    
    # Check for characters that would break macOS app bundles or filesystems
    # These characters: / \ : * ? " < > | are problematic in filenames
    if [[ "$name" =~ [/\\:*?\"\<\>|] ]]; then
        return 1  # Contains invalid characters
    fi
    
    return 0  # Name is valid
}

# Function: detect_browsers
# Purpose: Scans the system for installed Chromium-based browsers
# Parameters: None
# Returns: Sets global arrays DETECTED_BROWSERS and BROWSER_CONFIGS
# Notes: All Chromium browsers support the --host-resolver-rules flag we need
detect_browsers() {
    # Initialize local arrays to store results
    local browsers=()      # Will store display names of found browsers
    local browser_paths=()  # Will store full config strings for found browsers
    
    # Define known Chromium browser locations and metadata
    # Format: "Display Name:App Path:Executable Path:Icon Path"
    # The executable path is what we actually run, the app path is for detection
    local browser_configs=(
        "Google Chrome:/Applications/Google Chrome.app:/Applications/Google Chrome.app/Contents/MacOS/Google Chrome:/Applications/Google Chrome.app/Contents/Resources/app.icns"
        "Brave Browser:/Applications/Brave Browser.app:/Applications/Brave Browser.app/Contents/MacOS/Brave Browser:/Applications/Brave Browser.app/Contents/Resources/app.icns"
        "Microsoft Edge:/Applications/Microsoft Edge.app:/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge:/Applications/Microsoft Edge.app/Contents/Resources/app.icns"
        "Vivaldi:/Applications/Vivaldi.app:/Applications/Vivaldi.app/Contents/MacOS/Vivaldi:/Applications/Vivaldi.app/Contents/Resources/vivaldi.icns"
        "Opera:/Applications/Opera.app:/Applications/Opera.app/Contents/MacOS/Opera:/Applications/Opera.app/Contents/Resources/Opera.icns"
        "Arc:/Applications/Arc.app:/Applications/Arc.app/Contents/MacOS/Arc:/Applications/Arc.app/Contents/Resources/AppIcon.icns"
    )
    
    # Check which browsers are actually installed on this system
    for config in "${browser_configs[@]}"; do
        # Split the config string into components using colon as delimiter
        # IFS (Internal Field Separator) controls how bash splits strings
        IFS=':' read -r name app_path exec_path icon_path <<< "$config"
        
        # Test if the executable file exists (means browser is installed)
        if [[ -f "$exec_path" ]]; then
            browsers+=("$name")      # Add display name to found browsers
            browser_paths+=("$config")  # Keep full config for later use
        fi
    done
    
    # Set global arrays that other functions can access
    # Using global vars here because bash functions can't return arrays easily
    DETECTED_BROWSERS=("${browsers[@]}")
    BROWSER_CONFIGS=("${browser_paths[@]}")
}

# Function: select_browser
# Purpose: Handles browser selection logic (auto-select if one, prompt if multiple)
# Parameters: None
# Returns: Sets global variables for selected browser info
# Notes: This function provides the main user interaction for browser selection
select_browser() {
    # First, scan for available browsers
    detect_browsers
    
    # Handle case where no browsers are found
    if [[ ${#DETECTED_BROWSERS[@]} -eq 0 ]]; then
        echo "‚ùå No supported Chromium browsers found. Please install one of:"
        echo "   ‚Ä¢ Google Chrome"
        echo "   ‚Ä¢ Brave Browser" 
        echo "   ‚Ä¢ Microsoft Edge"
        echo "   ‚Ä¢ Vivaldi"
        echo "   ‚Ä¢ Opera"
        echo "   ‚Ä¢ Arc"
        exit 1  # Exit with error code since we can't proceed
    
    # Handle case where exactly one browser is found (auto-select)
    elif [[ ${#DETECTED_BROWSERS[@]} -eq 1 ]]; then
        # Automatically use the only available browser
        SELECTED_BROWSER_CONFIG="${BROWSER_CONFIGS[0]}"
        
        # Parse the browser configuration string to extract components
        IFS=':' read -r BROWSER_NAME BROWSER_APP_PATH BROWSER_EXEC_PATH BROWSER_ICON_PATH <<< "$SELECTED_BROWSER_CONFIG"
        echo "üåê Using detected browser: $BROWSER_NAME"
    
    # Handle case where multiple browsers are found (user choice required)
    else
        echo "üåê Multiple browsers detected. Please choose:"
        
        # Display numbered list of available browsers
        # ${!DETECTED_BROWSERS[@]} gives us the array indices
        for i in "${!DETECTED_BROWSERS[@]}"; do
            echo "   $((i+1))) ${DETECTED_BROWSERS[i]}"  # Display 1-based numbering
        done
        
        # Keep asking until we get a valid choice
        while true; do
            read -r -p "Select browser (1-${#DETECTED_BROWSERS[@]}): " choice
            
            # Validate that input is a number in the valid range
            # =~ is bash regex matching operator
            if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#DETECTED_BROWSERS[@]} ]]; then
                # Convert from 1-based user input to 0-based array index
                SELECTED_BROWSER_CONFIG="${BROWSER_CONFIGS[$((choice-1))]}"
                
                # Parse the selected browser's configuration
                IFS=':' read -r BROWSER_NAME BROWSER_APP_PATH BROWSER_EXEC_PATH BROWSER_ICON_PATH <<< "$SELECTED_BROWSER_CONFIG"
                echo "‚úì Selected: $BROWSER_NAME"
                break  # Exit the validation loop
            else
                # Invalid input, show error and ask again
                echo "‚ùå Invalid choice. Please enter a number between 1 and ${#DETECTED_BROWSERS[@]}"
            fi
        done
    fi
}


# Function: generate_random_icon
# Purpose: Creates a custom .icns icon file from PNG sources
# Parameters: $1 - Output path for .icns file, $2 - App name for consistent selection
# Returns: 0 on success, 1 on failure
# Notes: Uses hash-based selection to ensure same app name = same icon
generate_random_icon() {
    local icon_path="$1"   # Where to save the final .icns file
    local app_name="$2"    # App name used for consistent icon selection
    
    # Find the directory where this script is located
    # BASH_SOURCE[0] is the path to the current script file
    # dirname extracts just the directory part of that path
    local script_dir="$(dirname "${BASH_SOURCE[0]}")"
    local icons_dir="$script_dir/icons"
    
    # Verify that the icons directory exists
    if [[ ! -d "$icons_dir" ]]; then
        echo "‚ö†Ô∏è  Icons directory not found: $icons_dir"
        return 1  # Return error code
    fi
    
    # Get list of all PNG files in the icons directory
    # The glob pattern *.png expands to an array of matching filenames
    local icon_files=("$icons_dir"/*.png)
    
    # Check if any PNG files were actually found
    # If no files match, the glob returns the literal string "*.png"
    if [[ ! -f "${icon_files[0]}" ]]; then
        echo "‚ö†Ô∏è  No PNG icons found in: $icons_dir"
        return 1
    fi
    
    # Create consistent icon selection based on app name
    # cksum generates a checksum from the app name (deterministic hash)
    # cut -d' ' -f1 extracts just the numeric part of the checksum
    local name_hash=$(echo "$app_name" | cksum | cut -d' ' -f1)
    
    # Use modulo to map hash to array index (ensures consistent selection)
    local icon_index=$((name_hash % ${#icon_files[@]}))
    local selected_png="${icon_files[icon_index]}"
    
    # Create temporary directory for icon processing
    # mktemp -d creates a unique temporary directory
    local temp_dir=$(mktemp -d)
    local iconset_dir="$temp_dir/icon.iconset"
    mkdir -p "$iconset_dir"
    
    # macOS icons need multiple resolutions for different contexts
    # These sizes cover everything from menu bar to Finder icons
    local sizes=(16 32 64 128 256 512)
    
    for size in "${sizes[@]}"; do
        # Create standard resolution version
        local png_file="$iconset_dir/icon_${size}x${size}.png"
        
        # sips is macOS built-in image processing tool
        # -z resizes image, --out specifies output file
        # &>/dev/null suppresses all output (both stdout and stderr)
        sips -z $size $size "$selected_png" --out "$png_file" &>/dev/null
        
        # Create high-DPI (@2x) versions for Retina displays
        # Only create @2x versions for smaller sizes (larger ones don't need them)
        if [[ $size -le 256 ]]; then
            local size2x=$((size * 2))  # Double the size for @2x version
            local png_file_2x="$iconset_dir/icon_${size}x${size}@2x.png"
            sips -z $size2x $size2x "$selected_png" --out "$png_file_2x" &>/dev/null
        fi
    done
    
    # Convert the iconset directory to final .icns file
    # iconutil is macOS built-in tool for creating .icns files
    # -c icns means "create icns format"
    # -o specifies output file
    if iconutil -c icns -o "$icon_path" "$iconset_dir" &>/dev/null; then
        rm -rf "$temp_dir"  # Clean up temporary files
        return 0  # Success
    fi
    
    # If iconutil failed, clean up and return error
    rm -rf "$temp_dir"
    return 1
}

# Function: suggest_profile_name  
# Purpose: Converts app name into a filesystem-safe profile directory name
# Parameters: $1 - The app name to convert
# Returns: Prints suggested profile name to stdout
# Notes: Creates consistent, readable directory names from user-friendly app names
suggest_profile_name() {
    local app_name="$1"
    
    # Transform app name into filesystem-safe profile directory name:
    # 1. tr '[:upper:]' '[:lower:]' - Convert to lowercase
    # 2. sed 's/[^a-z0-9 ]//g' - Remove all non-alphanumeric chars except spaces  
    # 3. tr ' ' '-' - Replace spaces with dashes
    # 4. sed 's/--*/-/g' - Collapse multiple dashes into single dashes
    # 5. sed 's/^-\|-$//g' - Remove leading/trailing dashes
    # 
    # Example: "My Dev App (v2.0)" ‚Üí "my-dev-app-v20"
    echo "$app_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g' | tr ' ' '-' | sed 's/--*/-/g' | sed 's/^-\|-$//g'
}

# =============================================================================
# INSTALL/UNINSTALL SUBCOMMAND FUNCTIONS
# =============================================================================

# Function: install_subcommand
# Purpose: Download and install dev-browser from GitHub
# Parameters: None
# Returns: 0 on success, 1 on failure
install_subcommand() {
    local install_dir="$INSTALL_DIR_DEFAULT"
    local bin_dir="$BIN_DIR_DEFAULT"
    
    echo -e "${BLUE}üöÄ Dev Browser Remote Installer${NC}"
    echo "======================================"
    echo
    
    # Check if running on macOS
    if [[ "$(uname)" != "Darwin" ]]; then
        print_error "This tool only works on macOS"
        return 1
    fi
    
    # Check for required commands
    for cmd in curl mkdir chmod; do
        if ! command -v "$cmd" &> /dev/null; then
            print_error "Required command '$cmd' not found"
            return 1
        fi
    done
    
    # Create directories
    print_info "Setting up directories..."
    mkdir -p "$install_dir" "$install_dir/icons" "$bin_dir"
    
    # Download main script
    print_info "Downloading dev-browser..."
    if curl -fsSL "$RAW_URL/dev-browser" -o "$install_dir/dev-browser"; then
        chmod +x "$install_dir/dev-browser"
        print_success "Downloaded main script"
    else
        print_error "Failed to download main script"
        return 1
    fi
    
    # Download icons
    print_info "Downloading icon assets..."
    for i in {1..10}; do
        if curl -fsSL "$RAW_URL/icons/icon-$i.png" -o "$install_dir/icons/icon-$i.png" 2>/dev/null; then
            echo -n "."
        else
            print_warning "Failed to download icon-$i.png (continuing...)"
        fi
    done
    echo
    print_success "Downloaded icon assets"
    
    # Create wrapper script in bin
    print_info "Creating wrapper script..."
    cat > "$bin_dir/dev-browser" << 'EOF'
#!/bin/bash
exec "$HOME/.local/share/dev-browser/dev-browser" "$@"
EOF
    chmod +x "$bin_dir/dev-browser"
    print_success "Created wrapper script"
    
    # Check PATH
    echo
    if echo "$PATH" | grep -q "$bin_dir"; then
        print_success "Installation complete! Run: dev-browser"
    else
        print_success "Installation complete!"
        print_info "Add to your shell profile to use globally:"
        echo "  echo 'export PATH=\"\$HOME/.local/bin:\$PATH\"' >> ~/.zshrc"
        echo "  source ~/.zshrc"
        echo
        print_info "Or run directly: $bin_dir/dev-browser"
    fi
    
    print_info "Installation directory: $install_dir"
    print_info "GitHub repository: $REPO_URL"
    
    return 0
}

# Function: uninstall_subcommand
# Purpose: Remove dev-browser installation from system
# Parameters: None  
# Returns: 0 on success, 1 on failure
uninstall_subcommand() {
    local install_dir="$INSTALL_DIR_DEFAULT"
    local bin_dir="$BIN_DIR_DEFAULT"
    local wrapper_script="$bin_dir/dev-browser"
    
    echo -e "${BLUE}üóëÔ∏è  Dev Browser Uninstaller${NC}"
    echo "===================================="
    echo
    
    # Check if installed
    if [[ ! -d "$install_dir" ]] && [[ ! -f "$wrapper_script" ]]; then
        print_warning "Dev Browser doesn't appear to be installed"
        print_info "Installation directory: $install_dir"
        print_info "Wrapper script: $wrapper_script"
        return 0
    fi
    
    # Show what will be removed
    print_info "The following will be removed:"
    if [[ -d "$install_dir" ]]; then
        echo "  üìÅ Installation directory: $install_dir"
        echo "     $(find "$install_dir" -type f 2>/dev/null | wc -l | xargs) files"
    fi
    if [[ -f "$wrapper_script" ]]; then
        echo "  üîó Wrapper script: $wrapper_script"
    fi
    
    echo
    print_warning "This will NOT remove any apps you've created with dev-browser"
    print_info "Those are stored as .app bundles wherever you created them"
    echo
    
    # Confirmation - skip if running non-interactively
    if [[ -t 0 ]]; then
        # Interactive terminal
        read -p "Continue with uninstall? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Uninstall cancelled"
            return 0
        fi
    else
        # Running non-interactively
        print_info "Running in non-interactive mode, proceeding with uninstall..."
        sleep 2
    fi
    
    # Remove installation directory
    if [[ -d "$install_dir" ]]; then
        print_info "Removing installation directory..."
        if rm -rf "$install_dir"; then
            print_success "Removed $install_dir"
        else
            print_error "Failed to remove $install_dir"
        fi
    fi
    
    # Remove wrapper script
    if [[ -f "$wrapper_script" ]]; then
        print_info "Removing wrapper script..."
        if rm -f "$wrapper_script"; then
            print_success "Removed $wrapper_script"
        else
            print_error "Failed to remove $wrapper_script"
        fi
    fi
    
    # Check if .local/bin is empty and can be removed
    if [[ -d "$bin_dir" ]] && [[ -z "$(ls -A "$bin_dir" 2>/dev/null)" ]]; then
        print_info "Removing empty $bin_dir directory..."
        rmdir "$bin_dir" 2>/dev/null || true
    fi
    
    # Check if .local/share is empty and can be removed
    if [[ -d "$HOME/.local/share" ]] && [[ -z "$(ls -A "$HOME/.local/share" 2>/dev/null)" ]]; then
        print_info "Removing empty $HOME/.local/share directory..."
        rmdir "$HOME/.local/share" 2>/dev/null || true
    fi
    
    echo
    print_success "Uninstall complete!"
    print_info "Any browser apps you created are still available"
    print_info "You can manually delete them from Applications or wherever you saved them"
    
    return 0
}

# =============================================================================
# COMMAND LINE ARGUMENT PARSING  
# =============================================================================

# Parse subcommands and legacy flags
case "${1:-}" in
    # New subcommand interface
    install)
        install_subcommand
        exit $?
        ;;
    uninstall)
        uninstall_subcommand
        exit $?
        ;;
    create)
        # Continue to interactive mode (skip argument parsing)
        ;;
    list)
        list_apps
        exit $?
        ;;
    remove)
        if [[ -z "${2:-}" ]]; then
            echo "Error: remove requires an app ID"
            echo "Use '$0 list' to see available app IDs"
            exit 1
        fi
        remove_app "$2"
        exit $?
        ;;
    help)
        show_help
        exit 0
        ;;
    version)
        show_version
        exit 0
        ;;
    
    # No arguments - default to help
    "")
        show_help
        exit 0
        ;;
    
    # Unknown arguments
    *)
        echo "Error: Unknown command '$1'"
        echo "Run '$0 help' for usage information."
        exit 1
        ;;
esac

# =============================================================================
# MAIN SCRIPT EXECUTION - CREATE MODE
# =============================================================================

# Display welcome message for create mode
echo "üî® Dev Browser v${VERSION} - Create Mode"
echo "====================================="
echo

# Step 1: Detect and select browser to use
select_browser
echo

# Step 2: Ask where to place browser shortcuts
echo "üìÅ Installation directory (default: ~/dev-browsers):"
read -r -p "   Press Enter for default or specify path: " INSTALL_DIR

# If user just pressed Enter, use the default
if [[ -z "$INSTALL_DIR" ]]; then
    INSTALL_DIR="$HOME/dev-browsers"
else
    # Expand tilde in user-provided path
    INSTALL_DIR="${INSTALL_DIR/#\~/$HOME}"
fi

# Create the installation directory if it doesn't exist
mkdir -p "$INSTALL_DIR"
echo "Using directory: $INSTALL_DIR"
echo

# Step 3: Get app name from user (with validation)
while true; do
    read -r -p "üè∑Ô∏è  App name (e.g., 'Chrome Dev'): " APP_NAME
    
    # Validate the app name to ensure it won't break filesystem operations
    if validate_app_name "$APP_NAME"; then
        break  # Name is valid, exit validation loop
    else
        # Show error and ask again
        echo "‚ùå Invalid app name. Avoid special characters like / \\ : * ? \" < > |"
    fi
done

# Step 3: Generate and offer suggested profile directory name
# This provides a good default while allowing customization
SUGGESTED_PROFILE=$(suggest_profile_name "$APP_NAME")

echo "üë§ Profile name (suggested: '$SUGGESTED_PROFILE'):"
read -r -p "   Press Enter for suggested or specify custom: " PROFILE_NAME

# If user just pressed Enter, use the suggested name
if [[ -z "$PROFILE_NAME" ]]; then
    PROFILE_NAME="$SUGGESTED_PROFILE"
fi

# Step 4: Collect DNS mapping rules from user
echo
echo "üåê DNS Mapping Rules:"
echo "Enter hostname to IP mappings (one per line)"
echo "Format: hostname ip (e.g., example.com 192.168.1.100)"
echo "Press Enter twice when done:"

# Initialize array to store DNS rules
DNS_RULES=()

# Keep collecting rules until user enters empty line
while true; do
    read -r -p "   " rule
    
    # Check if user entered empty line (wants to finish)
    if [[ -z "$rule" ]]; then
        # Only allow finishing if at least one rule was entered
        if [[ ${#DNS_RULES[@]} -gt 0 ]]; then
            break  # Exit rule collection loop
        else
            echo "‚ùå Please enter at least one DNS rule, or press Ctrl+C to cancel"
        fi
    else
        # Validate rule format: hostname followed by IPv4 address
        # Regex breakdown:
        # ^[a-zA-Z0-9.-]+ - hostname (letters, numbers, dots, dashes)
        # [[:space:]]+ - one or more whitespace characters  
        # [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ - IPv4 format
        if [[ "$rule" =~ ^[a-zA-Z0-9.-]+[[:space:]]+[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            DNS_RULES+=("$rule")  # Add rule to array
            echo "   ‚úì Added: $rule"
        else
            echo "   ‚ùå Invalid format. Use: hostname ip (e.g., example.com 192.168.1.100)"
        fi
    fi
done

# Optional: Custom icon
echo
read -r -p "üñºÔ∏è  Custom icon path (optional): " ICON_PATH

# Show summary
echo
echo "üìã Summary:"
echo "   App: $APP_NAME"
echo "   Location: $INSTALL_DIR/$APP_NAME.app"
echo "   Profile: chrome-profiles/$PROFILE_NAME"
echo "   DNS Rules: ${#DNS_RULES[@]} rule(s)"
for rule in "${DNS_RULES[@]}"; do
    echo "     $rule"
done
if [[ -n "$ICON_PATH" ]]; then
    echo "   Icon: $ICON_PATH"
fi

echo
read -r -p "Create app? (Y/n): " confirm
if [[ "$confirm" =~ ^[Nn]$ ]]; then
    echo "Cancelled."
    exit 0
fi

# Generate app bundle in the specified installation directory
APP_BUNDLE="$INSTALL_DIR/$APP_NAME.app"
APP_DIR="$APP_BUNDLE/Contents"
MACOS_DIR="$APP_DIR/MacOS"
RESOURCES_DIR="$APP_DIR/Resources"

echo
echo "üì¶ Creating app bundle..."

# Create directory structure
mkdir -p "$MACOS_DIR" "$RESOURCES_DIR"

# Build Chromium browser arguments
BROWSER_ARGS="--user-data-dir=\"\$HOME/chrome-profiles/$PROFILE_NAME\""
PROFILE_DIR_NAME="chrome-profiles"

if [[ ${#DNS_RULES[@]} -gt 0 ]]; then
    MAP_RULES=""
    for rule in "${DNS_RULES[@]}"; do
        hostname=$(echo "$rule" | awk '{print $1}')
        ip=$(echo "$rule" | awk '{print $2}')
        if [[ -z "$MAP_RULES" ]]; then
            MAP_RULES="MAP $hostname $ip"
        else
            MAP_RULES="$MAP_RULES, MAP $hostname $ip"
        fi
    done
    BROWSER_ARGS="$BROWSER_ARGS --host-resolver-rules=\"$MAP_RULES\""
fi

# Create executable script
EXECUTABLE_NAME=$(echo "$APP_NAME" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
EXECUTABLE_PATH="$MACOS_DIR/$EXECUTABLE_NAME"

cat > "$EXECUTABLE_PATH" << EOF
#!/bin/bash

# $BROWSER_NAME launcher with custom DNS rules
# Generated by Dev Browser

BROWSER_PATH="$BROWSER_EXEC_PATH"

if [[ ! -f "\$BROWSER_PATH" ]]; then
    echo "‚ùå $BROWSER_NAME not found at \$BROWSER_PATH"
    echo "Please install $BROWSER_NAME first."
    exit 1
fi

# Create profile directory if it doesn't exist
mkdir -p "\$HOME/$PROFILE_DIR_NAME/$PROFILE_NAME"

# Launch $BROWSER_NAME with custom arguments
exec "\$BROWSER_PATH" $BROWSER_ARGS "\$@"
EOF

# Make executable
chmod +x "$EXECUTABLE_PATH"

# Create Info.plist
cat > "$APP_DIR/Info.plist" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>en</string>
    <key>CFBundleExecutable</key>
    <string>$EXECUTABLE_NAME</string>
    <key>CFBundleIdentifier</key>
    <string>com.custom.chrome.$(echo "$PROFILE_NAME" | tr '[:upper:]' '[:lower:]')</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$APP_NAME</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>LSMinimumSystemVersion</key>
    <string>10.9</string>
    <key>NSHighResolutionCapable</key>
    <true/>
    <key>NSSupportsAutomaticTermination</key>
    <true/>
    <key>NSSupportsSuddenTermination</key>
    <true/>
</dict>
</plist>
EOF

# Handle icon (custom or generated)
if [[ -n "$ICON_PATH" && -f "$ICON_PATH" ]]; then
    # Use custom icon provided by user
    cp "$ICON_PATH" "$RESOURCES_DIR/icon.icns"
    echo "   Custom icon added"
else
    # Generate random icon from available PNG icons
    if generate_random_icon "$RESOURCES_DIR/icon.icns" "$APP_NAME"; then
        echo "   Random icon generated"
    else
        echo "   Could not generate icon (using default)"
    fi
fi

# Add icon reference to Info.plist if icon exists
if [[ -f "$RESOURCES_DIR/icon.icns" ]]; then
    sed -i '' '/<\/dict>/i\
    <key>CFBundleIconFile</key>\
    <string>icon</string>
' "$APP_DIR/Info.plist"
fi

echo "   App bundle created: $APP_BUNDLE"
echo "   Profile location: ~/$PROFILE_DIR_NAME/$PROFILE_NAME"

# Register the app in the registry
if register_app; then
    echo "   Registered in app registry"
else
    echo "   Failed to register app (app will still work)"
fi

# Test the app
echo
if [[ -f "$BROWSER_EXEC_PATH" ]]; then
    echo "‚úÖ Success! Your custom $BROWSER_NAME app is ready."
else
    echo "App created successfully. Install $BROWSER_NAME to use it."
fi

echo "   App: $APP_BUNDLE"
echo "   Double-click to launch or drag to Applications/Dock"
echo
echo "Tips:"
echo "   ‚Ä¢ Each app uses a separate browser profile"
echo "   ‚Ä¢ DNS rules only apply to that specific app"
echo "   ‚Ä¢ Use '$0 list' to see all your apps"
echo
